{"componentChunkName":"component---node-modules-smooth-doc-src-templates-doc-js","path":"/docs/core/asyncActions/","result":{"data":{"mdx":{"fields":{"pageType":"doc","title":"Asynchronous actions","editLink":""},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Asynchronous actions\",\n  \"section\": \"UNDERSTANDING THE CORE\",\n  \"order\": 10\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"asynchronous-actions\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#asynchronous-actions\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"1em\",\n    width: \"1em\",\n    viewBox: \"0 0 16 16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Asynchronous actions\"), mdx(\"p\", null, \"Processing a chat event from user blocks other event from same user until the processing is finnished. It's very important for choosing right approach.\"), mdx(\"p\", null, \"There are two approches to drive asynchronous actions:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"blocking\"), \": Other Messenger events are waiting for limited time until the asynchronous operation is completed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"non blocking\"), \": Bot can process other chat events while asynchronous operation is in progress\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Blocking is important for keeping conversation state consistent.\")), mdx(\"h2\", {\n    \"id\": \"blocking-asynchronous-actions\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#blocking-asynchronous-actions\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"1em\",\n    width: \"1em\",\n    viewBox: \"0 0 16 16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Blocking Asynchronous actions\"), mdx(\"p\", null, \"For fast async operations you can use blocking approach. You can simply return a Promise or make function async. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"This approach is not recommended for production environments.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const { Router } = require('wingbot');\\nconst bot = new Router();\\n\\nfunction asyncAction () {\\n    return new Promise(r => setTimeout(() => r(Math.rand()), 100));\\n}\\n\\nbot.use(async (req, res) => {\\n    try {\\n        res.typingOn();\\n        const result = await asyncAction();\\n\\n        res.text('Complete!')\\n                .setState({ result });\\n    } catch (e) {\\n        res.text('Async action failed');\\n    }\\n});\\n\\nmodule.exports = bot;\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"It's not good to block messaging event processing with async actions, when action takes more then \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timeout\"), \" (Processor option), it can lead to overwriting state, when concurrent request arrives.\")), mdx(\"h2\", {\n    \"id\": \"non-blocking-asynchronous-actions\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#non-blocking-asynchronous-actions\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"1em\",\n    width: \"1em\",\n    viewBox: \"0 0 16 16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Non blocking asynchronous actions\"), mdx(\"p\", null, \"For non blocking approach is good to know, that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"only postBack can be called after an action is resolved\"), \".\\nAny other calls, like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setState()\"), \" will have no effect. This is the only right way to make non-blocking asynchronous operations.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const { Router } = require('wingbot');\\nconst bot = new Router();\\n\\nfunction asyncAction () {\\n    return new Promise(r => setTimeout(() => Math.rand(), 100));\\n}\\n\\nbot.use('/asyncComplete', (req, res) => {\\n    const { result, err } = req.actionData();\\n    if (err) {\\n        res.text('Async action failed');\\n    } else {\\n        res.text('Complete!')\\n                .setState({ result });\\n    }\\n});\\n\\nbot.use((req, res, postBack) => {\\n    res.typingOn();\\n    postBack('asyncComplete', async () => {\\n        try {\\n            const result = await asyncAction();\\n            return { result };\\n        } catch (err) {\\n            return err;\\n        }\\n    });\\n});\\n\\nmodule.exports = bot;\\n\")), mdx(\"h2\", {\n    \"id\": \"loading-attachments-to-buffer\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#loading-attachments-to-buffer\",\n    \"aria-hidden\": true,\n    \"className\": \"anchor\"\n  }, mdx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    height: \"1em\",\n    width: \"1em\",\n    viewBox: \"0 0 16 16\"\n  }, mdx(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Loading Attachments to Buffer\"), mdx(\"p\", null, \"Most simpliest way to upload attachments is converting them to base64 buffer:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const { Router, bufferloader } = require('wingbot');\\nconst bot = new Router();\\n\\nfunction asyncAction () {\\n    return new Promise(r => setTimeout(() => Math.rand(), 100));\\n}\\n\\nbot.use('/uploadComplete', (req, res) => {\\n    const { result, err } =\\n    if (!err) {\\n        res.text('Complete!')\\n                .setState({ result });\\n    } else if (err.code === 400) {\\n        res.text('Upload size exceeded');\\n    } else {\\n        res.text('Async action failed');\\n    }\\n});\\n\\nbot.use((req, res, postBack) => {\\n    // wait method is usefull for testing\\n    if (!req.isAttachment()) {\\n        return Router.CONTINUE;\\n    }\\n    res.typingOn();\\n    postBack('uploadComplete', async () => {\\n        try {\\n            const buf = bufferloader(req.attachmentUrl(), 1024);\\n            return { result: buf.toString('base64') };\\n        } catch (err) {\\n            return { err };\\n        }\\n    });\\n});\\n\\nmodule.exports = bot;\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#asynchronous-actions","title":"Asynchronous actions","items":[{"url":"#blocking-asynchronous-actions","title":"Blocking Asynchronous actions"},{"url":"#non-blocking-asynchronous-actions","title":"Non blocking asynchronous actions"},{"url":"#loading-attachments-to-buffer","title":"Loading Attachments to Buffer"}]}]}}},"pageContext":{"id":"604ca361-f36f-58c9-91f3-38c3697efdb3"}},"staticQueryHashes":["1122327541","1339625561","148928582","2140385554","3442269102","4275725850"]}